<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tutorials · DelaySSAToolkit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://palmtree2013.github.io/DelaySSAToolkit.jl/tutorials/tutorials/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaySSAToolkit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Tutorials</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#First-route:-JumpSystem-DiscreteProblem-DelayJumpSet"><span>First route: <code>JumpSystem + DiscreteProblem + DelayJumpSet</code></span></a></li><li><a class="tocitem" href="#Second-route:-JumpSet-DiscreteProblem-DelayJumpSet"><span>Second route: <code>JumpSet + DiscreteProblem + DelayJumpSet</code></span></a></li></ul></li><li><a class="tocitem" href="../bursty/">A bursty model with delay</a></li><li><a class="tocitem" href="../delay_degradation/">A birth-death example with delay degradation</a></li><li><a class="tocitem" href="../delay_multidegradation/">A multi-next-delay example</a></li><li><a class="tocitem" href="../heterogeneous_delay/">A birth-death model with heterogeneous fixed delays</a></li></ul></li><li><span class="tocitem">Algorithm</span><ul><li><a class="tocitem" href="../../algorithms/notations/">Notations and Basic Concepts</a></li><li><a class="tocitem" href="../../algorithms/delayrejection/">Delay Rejection Method Algorithm</a></li><li><a class="tocitem" href="../../algorithms/delaydirect/">Delay Direct Method Algorithm</a></li><li><a class="tocitem" href="../../algorithms/delaymnrm/">Delay Modified Next Reaction Method Algorithm</a></li></ul></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Tutorials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Tutorials</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/palmtree2013/DelaySSAToolkit.jl/blob/master/docs/src/tutorials/tutorials.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="seir_model"><a class="docs-heading-anchor" href="#seir_model">Tutorials</a><a id="seir_model-1"></a><a class="docs-heading-anchor-permalink" href="#seir_model" title="Permalink"></a></h1><p>This tutorial is aims to explain how to use DelaySSAToolkit to define chemical reaction models, solve the problem and visualize the results. To demonstrate the functionalities, we will consider a specific case from epideimc modelling as follows</p><p class="math-container">\[S+I\xrightarrow{\rho}E+I\\
I\stackrel{r}{\rightarrow}R\]</p><p>and <span>$S+I\xrightarrow{\rho} E+I$</span> will trigger <span>$E\Rightarrow I$</span> after <span>$\tau$</span> time, where <span>$S$</span>, <span>$I$</span> and <span>$R$</span> are the susceptible, infected and removed populations. <span>$E$</span> represents the exposed population. It means, wtih rate <span>$\rho$</span>, a susceptible contacted by an infected will become an individual that is exposed to the disease and then it takes certain amount of time delay <span>$\tau$</span> to become an infected inidividual.</p><h1 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h1><p>What differs from the Markov process that can be modelled via SSA is the introduction of <strong>delay reactions</strong>. To show how we incorporate the delay reactions into the Markovian system, we first need to define the Markovian part and then its non-Markovian part. These two parts mainly form a <code>DelayJumpProblem</code>. Here we show two routes to define our delay system, one way is based on <code>JumpSystem</code>, <code>DiscreteProblem</code> and <code>DelayJumpSet</code>, the other is based on <code>JumpSet</code>, <code>DiscreteProblem</code> and <code>DelayJumpSet</code>.</p><h2 id="First-route:-JumpSystem-DiscreteProblem-DelayJumpSet"><a class="docs-heading-anchor" href="#First-route:-JumpSystem-DiscreteProblem-DelayJumpSet">First route: <code>JumpSystem + DiscreteProblem + DelayJumpSet</code></a><a id="First-route:-JumpSystem-DiscreteProblem-DelayJumpSet-1"></a><a class="docs-heading-anchor-permalink" href="#First-route:-JumpSystem-DiscreteProblem-DelayJumpSet" title="Permalink"></a></h2><h3 id="Markovian_part"><a class="docs-heading-anchor" href="#Markovian_part">Markovian part</a><a id="Markovian_part-1"></a><a class="docs-heading-anchor-permalink" href="#Markovian_part" title="Permalink"></a></h3><p><a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a> provides a comprehensive interface to modelling reaction networks in Julia and can be used to construct models fully-compatible with DelaySSAToolkit. For more details on how to construct a reaction network, we recommend reading <a href="https://catalyst.sciml.ai/stable/tutorials/using_catalyst/">Catalyst&#39;s tutorial</a>. In our example, the model can be defined as:</p><pre><code class="language-julia hljs">rn = @reaction_network begin
    ρ, S+I --&gt; E+I
    r, I --&gt; R
end ρ r</code></pre><p>We can easily obtain <code>Jumpsystem</code> from the reaction network <code>rn</code> that is previously defined using Catalys interface.</p><pre><code class="language-julia hljs">jumpsys = convert(JumpSystem, rn, combinatoric_ratelaws=false)</code></pre><p>where <code>combinatoric_ratelaws</code> is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. The default, <code>combinatoric_ratelaws=true</code>, corresponds to rescaling the passed in rate constants. The default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie [1]. This means that for a reaction such as <span>$2A \overset{k}{\rightarrow} B$</span>, the jump rate function constructed by <code>MassActionJump</code> would be <code>k*A*(A-1)/2!</code>. For a trimolecular reaction like <span>$3A \overset{k}{\rightarrow} B$</span> the rate function would be <code>k*A*(A-1)*(A-2)/3!</code>. To <em>avoid</em> having the reaction rates rescaled (by <code>1/2</code> and <code>1/6</code> for these two examples), one can pass the <code>JumpSystem</code> constructor the optional named parameter <code>combinatoric_ratelaws=false</code> see <a href="https://catalyst.sciml.ai/stable/tutorials/using_catalyst/#Reaction-rate-laws-used-in-simulations">Reaction rate laws used in simulations</a> for details.</p><p>With the initial conditions, we can then define <code>DiscreteProblem</code></p><pre><code class="language-julia hljs">u0 = [999,1,0,0] # S, I, E, R
de_chan0 = [[]]
tf = 400.
tspan = (0,tf)
ps = [1e-4, 1e-2] # parameters for ρ, r
τ = 20.
dprob = DiscreteProblem(jumpsys,u0,tspan,ps)</code></pre><p>where <code>DiscreteProblem</code> inputs <code>jumpsys</code>, and the initial condition of reactants <code>u0</code> , the simulation timespan <code>tspan</code> and the reaction rates <code>ps</code>.</p><h3 id="Non-Markovian-part"><a class="docs-heading-anchor" href="#Non-Markovian-part">Non-Markovian part</a><a id="Non-Markovian-part-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Markovian-part" title="Permalink"></a></h3><p>The non-Markovian part consists of three elements:</p><ul><li>delay trigger reactions: those reactions in the <a href="#Markovian_part">Markovian part</a> that trigger the change of the state of the delay channels or/and the state of the reactants upon initiation.</li><li>delay interrupt reactions: those reactions in the <a href="#Markovian_part">Markovian part</a> that change the state of the delay channels or/and the state of the reactants in the middle of on-going delay reactions.</li><li>delay complete reactions: those reactions that are initiated by delay trigger reactions and change the state of the delay channels or/and the state of the reactants upon completion.</li></ul><p>With these three definitions in mind and based on this particular example, we define the <code>DelayJumpSet</code> by</p><pre><code class="language-julia hljs">delay_trigger_affect! = function (integrator, rng)
    append!(integrator.de_chan[1], τ)
end
delay_trigger = Dict(1=&gt;delay_trigger_affect!)
delay_interrupt = Dict()
delay_complete = Dict(1=&gt;[2=&gt;1, 3=&gt;-1])
delayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)</code></pre><ul><li><code>delay_trigger::Dict</code>  A dictionary that contains<ul><li><p>Keys: Indices of reactions defined in <code>JumpSystem</code> that can trigger the delay reaction see <a href="#indice_notice">indices in the <code>JumpSystem</code></a>. Here we have the first reaction <span>$S+I\Rightarrow E+ I$</span> that will trigger the transfer from <span>$E$</span> to <span>$I$</span> after time <span>$\tau$</span>, hence the key here is <code>1</code>.</p></li><li><p>Values: A update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the first delay channel will be added a delay time <span>$\tau$</span>.</p></li></ul></li><li><code>delay_interrupt::Dict</code><ul><li>There are no delay interrupt reactions in this example so we set <code>delay_interrupt = Dict()</code>.</li></ul></li><li><code>delay_complete::Dict</code> <ul><li>Keys: Indices of delay channels.</li><li>Values: A vector of <code>Pair</code>s, mapping species index to net change of stoichiometric coefficient.</li></ul></li></ul><p>We refer to <a href="tutorials/bursty.md/#Defining-a-DelayJumpSet">Defining a <code>DelayJumpSet</code></a> and <a href="tutorials/delay_degradation.md/#Defining-a-DelayJumpSet">Defining a <code>DelayJumpSet</code>(birth-death example)</a> for more details.</p><h3 id="indice_notice"><a class="docs-heading-anchor" href="#indice_notice">Remark on Reaction Indices</a><a id="indice_notice-1"></a><a class="docs-heading-anchor-permalink" href="#indice_notice" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>JumpSystem</code> might change the order of the reactions that is arranged in your reaction network. Internally, all MassActionJumps are ordered before ConstantRateJumps (with the latter internally ordered in the same order they were passed in). The same principle applies for the construction of <code>JumpSet</code>.</p></div></div><p>At last, we can define the <code>DelayJumpProblem</code> by </p><pre><code class="language-julia hljs">jprob = DelayJumpProblem(jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0, save_positions=(true,true))</code></pre><p>where <code>DelayJumpProblem</code> inputs <code>jumpsys</code>,<code>DiscreteProblem</code>, <code>DelayJumpSet</code>, the algorithm we choose and the initial condition of the delay channel <code>de_chan0</code>.</p><p>Let&#39;s put aside our <code>DelayJumpProblem</code> for the moment and see how to define the delay system in another way. </p><h2 id="Second-route:-JumpSet-DiscreteProblem-DelayJumpSet"><a class="docs-heading-anchor" href="#Second-route:-JumpSet-DiscreteProblem-DelayJumpSet">Second route: <code>JumpSet + DiscreteProblem + DelayJumpSet</code></a><a id="Second-route:-JumpSet-DiscreteProblem-DelayJumpSet-1"></a><a class="docs-heading-anchor-permalink" href="#Second-route:-JumpSet-DiscreteProblem-DelayJumpSet" title="Permalink"></a></h2><p>Now we explain how to define the <code>DelayJumpProblem</code> in another way. To that aim, we should first define the parameters and the mass-action jump (see <a href="https://diffeq.sciml.ai/stable/types/jump_types/#Defining-a-Mass-Action-Jump">Defining a Mass Action Jump</a> for details) and construct <code>Jumpset</code>.</p><h3 id="Markovian-part"><a class="docs-heading-anchor" href="#Markovian-part">Markovian part</a><a id="Markovian-part-1"></a><a class="docs-heading-anchor-permalink" href="#Markovian-part" title="Permalink"></a></h3><pre><code class="language-julia hljs">ρ, r = [1e-4, 1e-2]
rate1 = [ρ, r]
reactant_stoich = [[1=&gt;1,2=&gt;1],[2=&gt;1]]
net_stoich = [[1=&gt;-1,3=&gt;1],[2=&gt;-1,4=&gt;1]]
mass_jump = MassActionJump(rate1, reactant_stoich, net_stoich; scale_rates =false)
jumpset = JumpSet((),(),nothing,mass_jump)</code></pre><p>The <code>JumpSet</code> consists of four inputs, namely variable jumps, constant rate jumps, regular jumps and mass-action jumps. As far as discrete stochastic simulation is concerned, we only focus on constant rate jumps and mass-action jumps which is the second and fourth inputs of <code>JumpSet</code> (see <a href="https://diffeq.sciml.ai/stable/types/jump_types/">different jump types</a> for more details). Here we only have two mass-action jumps that are wrapped in <code>mass_jump</code>.</p><p>Then we initialise the problem by setting</p><pre><code class="language-julia hljs">u0 = [999,1,0,0]
de_chan0 = [[]]
tf = 400.
tspan = (0,tf)
τ = 20.</code></pre><p>As before, we can define the <code>DiscreteProblem</code></p><pre><code class="language-Julia hljs">dprob = DiscreteProblem(u0, tspan)</code></pre><h3 id="Non-Markovian-part-2"><a class="docs-heading-anchor" href="#Non-Markovian-part-2">Non-Markovian part</a><a class="docs-heading-anchor-permalink" href="#Non-Markovian-part-2" title="Permalink"></a></h3><p>In the same way, we can define the  <code>DelayJumpSet</code> by</p><pre><code class="language-julia hljs">delay_trigger_affect! = function (de_chan, rng)
    append!(de_chan[1], τ)
end
delay_trigger = Dict(1=&gt;delay_trigger_affect!)
delay_complete = Dict(1=&gt;[2=&gt;1, 3=&gt;-1])
delay_interrupt = Dict()
delayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)</code></pre><p>Now we can define the problem</p><pre><code class="language-julia hljs">djprob = DelayJumpProblem(dprob, DelayRejection(), jumpset, delayjumpset, de_chan0, save_positions=(true,true)).</code></pre><p>At last, we can solve the problem and visualize it</p><pre><code class="language-julia hljs">sol = solve(djprob, SSAStepper())</code></pre><p><img src="../../assets/seir.svg" alt="seir"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../bursty/">A bursty model with delay »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 28 December 2021 07:11">Tuesday 28 December 2021</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
