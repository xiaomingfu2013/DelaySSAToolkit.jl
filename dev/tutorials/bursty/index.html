<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A bursty model with delay · DelaySSAToolkit.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://palmtree2013.github.io/DelaySSAToolkit.jl/tutorials/bursty/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DelaySSAToolkit.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../tutorials/">Tutorials</a></li><li class="is-active"><a class="tocitem" href>A bursty model with delay</a><ul class="internal"><li><a class="tocitem" href="#Model"><span>Model</span></a></li><li><a class="tocitem" href="#Markovian-part"><span>Markovian part</span></a></li><li><a class="tocitem" href="#Non-Markovian-part"><span>Non-Markovian part</span></a></li><li><a class="tocitem" href="#Visualisation"><span>Visualisation</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../delay_degradation/">A birth-death example with delay degradation</a></li><li><a class="tocitem" href="../heterogeneous_delay/">A birth-death model with heterogeneous fixed delays</a></li><li><a class="tocitem" href="../delay_oscillator/">An auto-regulatory model of oscillatory gene expression</a></li><li><a class="tocitem" href="../stochastic_delay/">A telegraph model of stochastic delay</a></li></ul></li><li><span class="tocitem">Algorithm</span><ul><li><a class="tocitem" href="../../algorithms/notations/">Notations and Basic Concepts</a></li><li><a class="tocitem" href="../../algorithms/delayrejection/">Delay Rejection Method Algorithm</a></li><li><a class="tocitem" href="../../algorithms/delaydirect/">Delay Direct Method Algorithm</a></li><li><a class="tocitem" href="../../algorithms/delaymnrm/">Delay Modified Next Reaction Method Algorithm</a></li></ul></li><li><a class="tocitem" href="../../theory/">Theory</a></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>A bursty model with delay</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A bursty model with delay</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/palmtree2013/DelaySSAToolkit.jl/blob/master/docs/src/tutorials/bursty.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="bursty_model"><a class="docs-heading-anchor" href="#bursty_model">A bursty model with delay</a><a id="bursty_model-1"></a><a class="docs-heading-anchor-permalink" href="#bursty_model" title="Permalink"></a></h1><h2 id="Model"><a class="docs-heading-anchor" href="#Model">Model</a><a id="Model-1"></a><a class="docs-heading-anchor-permalink" href="#Model" title="Permalink"></a></h2><p>We study the following gene expression model which does not have an explicit gene state description and that the product (RNA or protein denoted as P) is actively transcribed in bursts whose size are distributed according to a geometric distribution. This means the propensity functions is given by <span>$f(n) = ab^n/(1+b)^{n+1}$</span> for any positive integer <span>$n$</span>. The bursty model writes: </p><p class="math-container">\[\frac{ab^n}{(1+b)^{n+1}}: \emptyset \rightarrow nP \text{ triggers }nP\Rightarrow\emptyset \text{ after $\tau$ time.}\]</p><h2 id="Markovian-part"><a class="docs-heading-anchor" href="#Markovian-part">Markovian part</a><a id="Markovian-part-1"></a><a class="docs-heading-anchor-permalink" href="#Markovian-part" title="Permalink"></a></h2><p>The system has an explict solution which is obtained in [1, Supplementary Note Section 2]. We first construct reaction network</p><pre><code class="language-julia hljs">@parameters a b t
@variables X(t)
burst_sup = 30
rxs = [Reaction(ab^n/(1+b)^{n+1},nothing,[X],nothing,[n]) for n in 1:burst_sup]
rxs = vcat(rxs)
@named rs = ReactionSystem(rxs,t,[X],[a,b])</code></pre><p>In the example, we set <span>$a=0.0282$</span> and <span>$b=3.46$</span> and set the upper bound of bursting as <code>burst_sup = 30</code>. This means we ignore all the reactions <span>$ab^n/(1+b)^{n+1}:\emptyset \rightarrow nP$</span> for any <span>$n &gt; 30$</span> where the reaction rate <span>$ab^n/(1+b)^{n+1} \sim 10^{-6}$</span>.  We first convert the <code>ReactionSystem</code> to a <code>JumpSystem</code> and initialise the discrete problem by</p><pre><code class="language-julia hljs">jumpsys = convert(JumpSystem, rs, combinatoric_ratelaws=false)
u0 = [0]
tf = 200.
tspan = (0,tf)
timestamp = 0:1:tf
ps = [0.0282, 3.46]
τ = 130.
dprob = DiscreteProblem(jumpsys,u0,tspan,ps)</code></pre><h2 id="Non-Markovian-part"><a class="docs-heading-anchor" href="#Non-Markovian-part">Non-Markovian part</a><a id="Non-Markovian-part-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Markovian-part" title="Permalink"></a></h2><p>Next, we define the non-Markovian part. Here we mainly need to consider the delay trigger reactions that is, for <em>n</em>th-reaction, <span>$\emptyset \rightarrow nP$</span>, the delay channel will be added of a vector <span>$[\tau,\ldots,\tau]$</span> of size <span>$n$</span>. Thus, we have</p><pre><code class="language-julia hljs">delay_trigger_affect! = []
for n in 1:burst_sup
    push!(delay_trigger_affect!, function (integrator, rng)
    append!(integrator.de_chan[1], fill(τ, n))
    end)
end
delay_trigger = Dict([Pair(i, delay_trigger_affect![i]) for i in 1:burst_sup])
delay_interrupt = Dict()
delay_complete = Dict(1=&gt;[1=&gt;-1])
delayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)</code></pre><ul><li><code>delay_trigger</code><ul><li>Keys: Indices of reactions defined in <code>jumpset</code> that can trigger the delay reaction.  For each <span>$n= 1,\ldots,30,$</span> the reaction <span>$ab^n/(1+b)^{n+1}:\emptyset \rightarrow nP$</span>, that will trigger <span>$nP$</span> to degrade after time <span>$\tau$</span>.</li><li>Values: An update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the delay channel (which is the channel for <span>$P$</span>) will be added an array of delay time <span>$\tau$</span> depending on the bursting number <span>$n$</span>.</li></ul></li><li><code>delay_interrupt</code> <ul><li>There are no delay interrupt reactions in this example so we set <code>delay_interrupt = Dict()</code>.</li></ul></li><li><code>delay_complete</code> <ul><li>Keys: Indices of delay channel. Here we only have one delay channel for <span>$P$</span>.</li><li>Values: A vector of <code>Pair</code>s, mapping species index to net change of stoichiometric coefficient. Here the degradation will cause the first species to have a net change of <span>$-1$</span>. In this example, one might have <span>$nP$</span> leaving the system simultaneously. Such multiple delay reactions are taken care of automatically by the delay SSA algorithm.</li></ul></li></ul><p>We define the delay jump problem by </p><pre><code class="language-julia hljs">de_chan0 = [[]]
jprob = DelayJumpProblem(jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0, save_positions=(false,false))</code></pre><p>where <code>de_chan0</code> is the initial condition for the delay channel where we assume no ongoing delay reactions at <span>$t=0$</span>. <code>DelayJumpProblem</code> inputs <code>JumpSystem</code>, <code>DelayJumpProblem</code>, <code>DelayJumpSet</code>, the algorithm and the initial condition of the delay channel <code>de_chan0</code>.</p><h2 id="Visualisation"><a class="docs-heading-anchor" href="#Visualisation">Visualisation</a><a id="Visualisation-1"></a><a class="docs-heading-anchor-permalink" href="#Visualisation" title="Permalink"></a></h2><pre><code class="language-julia hljs">using DiffEqJump
ensprob = EnsembleProblem(jprob)
@time ens = solve(ensprob, SSAStepper(), EnsembleThreads(), trajectories=10^5)</code></pre><p>Then check with the exact probability distribution <img src="../../assets/bursty.svg" alt="bursty"/></p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1] Qingchao Jiang, Xiaoming Fu, Shifu Yan, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, &quot;Neural network aided approximation and parameter inference of non-Markovian models of gene expression&quot;. Nature communications, (2021) 12(1), 1-12. <a href="https://doi.org/10.1038/s41467-021-22919-1">https://doi.org/10.1038/s41467-021-22919-1</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorials/">« Tutorials</a><a class="docs-footer-nextpage" href="../delay_degradation/">A birth-death example with delay degradation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Monday 3 January 2022 02:54">Monday 3 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
