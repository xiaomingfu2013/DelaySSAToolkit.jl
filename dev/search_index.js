var documenterSearchIndex = {"docs":
[{"location":"tutorials/bursty/#A-bursty-model-with-delay","page":"A bursty model with delay","title":"A bursty model with delay","text":"","category":"section"},{"location":"tutorials/bursty/#Model-definition","page":"A bursty model with delay","title":"Model definition","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"We study the following model which does not have an explicit gene state description and that the product (RNA or protein denoted as P) is actively transcribed in bursts whose size are distributed according to a geometric distribution. This means the propensity functions is is given by f(n) = ab^n(1+b)^n+1 for any positive integer n. Our bursty model writes:  The system has an explict solution which is obtained in [1, Supplementary Note Section 2]. We first construct reaction network","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"fracab^n(1+b)^n+1 emptyset rightarrow nP text triggers nPRightarrowemptyset text after tau time","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"The system has an explict solution which is obtained in [1, Supplementary Note Section 2]. We first construct reaction network","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"begin \n    @parameters a b t\n    @variables X(t)\n    burst_sup = 30\n    rxs = [Reaction(ab^n/(1+b)^{n+1},nothing,[X],nothing,[n]) for n in 1:burst_sup]\n    rxs = vcat(rxs)\n    @named rs = ReactionSystem(rxs,t,[X],[a,b])\nend","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"In the example, we set a=00282 and b=346 and set the upper bound of bursting as burst_sup = 30. This means we ignore all the reactions ab^n(1+b)^n+1emptyset rightarrow nP for any n  30 where the reaction rate ab^n(1+b)^n+1 sim 10^-6.  We first convert the ReactionSystem to a JumpSystem and initialise the problem by setting","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"jumpsys = convert(JumpSystem, rs, combinatoric_ratelaws=false)\nu0 = [0]\nde_chan0 = [[]]\ntf = 200.\ntspan = (0,tf)\ntimestamp = 0:1:tf\nps = [0.0282, 3.46]\nτ = 130.","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"where de_chan0 is the initial condition for the delay channel where we assume no ongoing delay reactions at t=0. Next, we define delay trigger funtion append!(de_chan[1], fill(τ, i)) for iin 1ldots30.","category":"page"},{"location":"tutorials/bursty/#Defining-a-DelayJumpSet","page":"A bursty model with delay","title":"Defining a DelayJumpSet","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"delay_trigger_affect! = []\nfor n in 1:burst_sup\n    push!(delay_trigger_affect!, function (de_chan, rng)\n    append!(de_chan[1], fill(τ, n))\n    end)\nend\ndelay_trigger_affect!\ndelay_trigger = Dict([Pair(i, delay_trigger_affect![i]) for i in 1:burst_sup])\ndelay_complete = Dict(1=>[1=>-1])\ndelay_interrupt = Dict()\ndelayjumpset = DelayJumpSet(delay_trigger, delay_complete, delay_interrupt)","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"delay_trigger\nKeys: Indices of reactions defined in jumpset that can trigger the delay reaction. Here we have burst_sup = 30 reactions ab^n(1+b)^n+1emptyset rightarrow nP, that will trigger nP to degrade after time tau.\nValues: A update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the delay channel (which is the channel for P) will be added an array of delay time tau depending on the bursting number n.\ndelay_interrupt There are no delayinterrupt reactions in this example so we set `delayinterrupt = Dict()`\ndelay_complete: \nKeys: Indices of delay channel. Here we only have one delay channel for P.\nValues: A vector of Pairs, mapping species id to net change of stoichiometric coefficient.","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"We define the delay SSA problem","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"dprob = DiscreteProblem(jumpsys,u0,tspan,ps)\njprob = DelayJumpProblem(jumpsys, dprob, DelayRejection(), delayjumpset, de_chan0, save_positions=(false,false))","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"where DelayJumpProblem inputs DelayJumpProblem, DelayJumpSet and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/bursty/#Visualisation","page":"A bursty model with delay","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"using DiffEqJump\nensprob = EnsembleProblem(jprob)\n@time ens = solve(ensprob, SSAStepper(), EnsembleThreads(),saveat=timestamp, trajectories=10^5)","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"Then check with the exact probability distribution (Image: bursty)","category":"page"},{"location":"tutorials/bursty/","page":"A bursty model with delay","title":"A bursty model with delay","text":"[1] Qingchao Jiang#, Xiaoming Fu#, Shifu Yan#, Runlai Li, Wenli Du, Zhixing Cao, Feng Qian, Ramon Grima, \"Neural network aided approximation and parameter inference of non-Markovian models of gene expression\". Nature communications, (2021) 12(1), 1-12. https://doi.org/10.1038/s41467-021-22919-1","category":"page"},{"location":"algorithms/delayrejection/#Delay-Rejection-Method-Algorithm","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"","category":"section"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"  Simulation methods for systems with delays need to calculate when reactions initiate and store when they complete. However, because of the delayed reactions, the propensity functions can change between initiation times. Bratsun et al. [1] and Barrio et al. [2] used an algorithm for computing the initiation times that is exactly like the original Gillespie Algorithm except that if there is a stored delayed reaction set to finish within a computed timestep, then the computed timestep is discarded, and the system is updated to incorporate the stored delayed reaction. The algorithm then attempts another step starting at its new state. This algorithm is called Rejection Method.","category":"page"},{"location":"algorithms/delayrejection/#Pseudo-code","page":"Delay Rejection Method Algorithm","title":"Pseudo code","text":"","category":"section"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set t = 0.\nCalculate the propensity function, a_k, for each reaction.\nSet a_0 = sum_k=1^M a_k.\nGenerate an independent uniform (01) random number, r_1, and set Delta = 1a_0 ln(1r_1).\nIf there is a delayed reaction set to finish in t t + Delta)\nDiscard Delta.\nUpdatetto be the time of the next delayed reaction,mu.\nUpdatexaccording to the stored reaction mu.\nElse\nGenerate an independent uniform(01) random number r_2.\nFind muin1ldots m such that\nsum_k=1^mu-1 a_k(t)  r_2 a_0  sum_k=1^mu a_k(t)\nIf muin textND, update the number of each molecular species according to reaction mu.\nIf muin textCD, store the information that at time t+tau_mu the system must be updated according to reaction mu.\nIf muin textICD, update the system according to the initiation of mu and store that at time t+tau_mu the system must be updated according to the completion of reaction mu.\nSet t = t +Delta\nEndif\nReturn to step 2 or quit.","category":"page"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"[1] Dmitri A. Bratsun, Dmitri N. Volfson, Jeff Hasty, and Lev S. Tsimring \"Non-Markovian processes in gene regulation (Keynote Address)\", Proc. SPIE 5845, Noise in Complex Systems and Stochastic Dynamics III, (23 May 2005). https://doi.org/10.1117/12.609707","category":"page"},{"location":"algorithms/delayrejection/","page":"Delay Rejection Method Algorithm","title":"Delay Rejection Method Algorithm","text":"[2]  Manuel Barrio, Kevin Burrage, André Leier, Tianhai Tian. \"Oscillatory Regulation of Hes1: Discrete Stochastic Delay Modelling and Simulation\", PLoS Computational Biology, 10.1371(2006). https://doi.org/10.1371/journal.pcbi.0020117","category":"page"},{"location":"algorithms/notations/#Notations-and-Basic-Concepts","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"","category":"section"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"  Consider a system consisting of N geq 1 chemical species,X_1ldots X_N, undergoing M geq 1 chemical reactions through reaction channels R_1ldotsR_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature), a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)ldotsX_N(t)^T, where X_n(t)n = 1ldotsN, is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"  Delays, tau_k  0, in systems are between the initiation and completion of some, or all, of the reactions. Notice that the definition of tau_k  is not the next reaction time of the Next Reaction Method. We partition the reactions into three sets, those with no delays, denoted textND, those that change the state of the system only upon completion, denoted textCD, and those that change the state of the system at both initiation and completion, denoted textICD. The following assumption is based upon physical principles and serves as the base assumption for simulation methods of chemically reacting systems with delays:","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"beginaligned\na_k(X(t)) Delta t + omicron (t) =  text the probability that  reaction k \n text takes place in a small time interval t t + Delta t)\nendaligned","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"where omicron (Delta t)Delta t rightarrow 0  as  Delta t rightarrow 0.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"  Thus, no matter whether a reaction is contained in textND, textCD, or textICD, the number ofinitiationsat absolute timetwill be given by","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"textnumber of initiations of reaction  ktext by time  t = Y_kBig(int_0^t a_k(X(s)Big) mathrmds)","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"where the Y_k are independent, unit rate Poisson processes.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"  More specifically, if we define T_k(t) =int_0^t a_k(X(s)) mathrmds for each k, then it is relevant for us to consider Y_k(T_k(t)). We will call T_k(t) the \"internal time\" for reaction k.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"  Because the assumption above, and hence equation t, only pertains to the initiation times of reactions we must handle the completions separately. There are three different types of reactions, so there are three cases that need consideration.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 1: If reaction k is in textND and initiates at time t, then the system is updated by losing the reactant species and gaining the product species at the time of initiation.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 2: If reaction k is in textCD and initiates at time t, then the system is updated only at the time of completion, t + tau_k, by losing the reactant species and gaining the product species.","category":"page"},{"location":"algorithms/notations/","page":"Notations and Basic Concepts","title":"Notations and Basic Concepts","text":"Case 3: If reaction k is in textICD and initiates at time t, then the system is updated by losing the reactant species at the time of initiation, t, and is updated by gaining the product species at the time of completion,t + tau_k.","category":"page"},{"location":"api/#Main-API","page":"API","title":"Main API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [DelaySSAToolkit]","category":"page"},{"location":"api/#DelaySSAToolkit.AbstractDSSAJumpAggregator","page":"API","title":"DelaySSAToolkit.AbstractDSSAJumpAggregator","text":"An aggregator interface for SSA-like algorithms.\n\nRequired Fields\n\nnext_jump          # the next jump to execute\nprev_jump          # the previous jump that was executed\nnext_jump_time     # the time of the next jump\nend_time           # the time to stop a simulation\ncur_rates          # vector of current propensity values\nsum_rate           # sum of current propensity values\nma_jumps           # any MassActionJumps for the system (scalar form)\nrates              # vector of rate functions for ConstantRateJumps\naffects!           # vector of affect functions for ConstantRateJumps\nsave_positions     # tuple for whether to save the jumps before and/or after event\nrng                # random number generator\n\nOptional fields:\n\ndep_gr             # dependency graph, dep_gr[i] = indices of reactions that should                      # be updated when rx i occurs.    \n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.ChannelSolution","page":"API","title":"DelaySSAToolkit.ChannelSolution","text":"-delaytrigger: Dict 记录哪些 reactions会引发一个delay反应：keys：reaction的idx，values Dict 记录在第i个delaychannel 增加一个列向量 为delay的时间. 这里包含了两种情况，1.在delay前对状态改变(pre-delay)，这个是由reaction来完成的；2.在delay后对状体改变(post-delay)，这个是由delayvec中完成的 -delayinterrupt: Dict reactions 能够对 delay channel中造成影响的 keys : reaction idx ->  returns a Function :  how the molecules in a channel or multiple channels  will be consumed -delay_complete: Dict keys:第 i 个delay channel values 完成后会引起一个 (post-delay) state-update, values: stoichiometric vector 长度是反应物长度\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DSSAIntegrator","page":"API","title":"DelaySSAToolkit.DSSAIntegrator","text":"dechan: 记录delaychannel, Dict(), keys 记录哪一个delaychannel, values 记录在这个delaychannel中所等待的时间列表\nprevdechan:  For saveat update\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayDirectJumpAggregation","page":"API","title":"DelaySSAToolkit.DelayDirectJumpAggregation","text":"#TODO\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayJumpSet","page":"API","title":"DelaySSAToolkit.DelayJumpSet","text":"-delaytrigger: Dict 记录哪些 reactions会引发一个delay反应：keys：reaction的idx, values: delaytrigger_affect!\n\n-delay_complete: Dict keys:第 i 个delay channel values 完成后会引起一个 (post-delay) state-update, values: stoichiometric vector 长度是反应物长度\n\n-delay_interrupt: Dict reactions 能够对 delay channel中造成影响的 keys : reaction idx ->  returns a Function :  how the molecules in a channel or multiple channels  will be consumed\n\ndelaytriggerset: 把所有会引发delay 的 reactions 的 idx 收集起来\ndelayinterruptset: 把所有会引发delay channel 改变的 reactions 的 idx 收集起来\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayMNRMJumpAggregation","page":"API","title":"DelaySSAToolkit.DelayMNRMJumpAggregation","text":"next_delay: the idx of delay channel \nnumnextdelay: how many times needed for updating the states in the next_delay channel\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayRejection","page":"API","title":"DelaySSAToolkit.DelayRejection","text":"Gillespie, Daniel T. (1976). A General Method for Numerically Simulating the Stochastic Time Evolution of Coupled Chemical Reactions. Journal of Computational Physics. 22 (4): 403–434. doi:10.1016/0021-9991(76)90041-3.\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.DelayRejectionJumpAggregation","page":"API","title":"DelaySSAToolkit.DelayRejectionJumpAggregation","text":"next_delay: the idx of delay channel \nnumnextdelay: how many times needed for updating the states in the next_delay channel\n\n\n\n\n\n","category":"type"},{"location":"api/#DelaySSAToolkit.calculate_jump_rate-NTuple{7, Any}","page":"API","title":"DelaySSAToolkit.calculate_jump_rate","text":"calculate_jump_rate(ma_jumps, rates, u, params, t, rx)\n\nRecalculate the rate for the jump with index rx.\n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.compare_delay!-Tuple{DelaySSAToolkit.AbstractDSSAJumpAggregator, Any, Any, Any, Any}","page":"API","title":"DelaySSAToolkit.compare_delay!","text":"Compare delay dt with reaction dt \n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.create_Tstruct-Union{Tuple{Array{Vector{T}, 1}}, Tuple{T}} where T","page":"API","title":"DelaySSAToolkit.create_Tstruct","text":"function create_Tstruct(de_chan::Vector{Vector{T}})\n\ncalculate Tstruct according to the de_chan\n\nArguments\n\nde_chan::Vector{Vector{T}}: where T is the tpye of t\n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.fill_rates_and_sum!-Tuple{DelaySSAToolkit.AbstractDSSAJumpAggregator, Any, Any, Any}","page":"API","title":"DelaySSAToolkit.fill_rates_and_sum!","text":"fill_rates_and_sum!(p::AbstractDSSAJumpAggregator, u, params, t)\n\nReevaluate all rates and their sum.\n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.find_next_delay_vec-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, T}} where T","page":"API","title":"DelaySSAToolkit.find_next_delay_vec","text":"find_next_delay_vec(A::Vector{Vector{T}}, x::T)\n\nReturns two vectors. The first is the position index vector position_index of vector A, and the second is the vector num_in_vec composed of the number of values in the position index corresponding to position_index equal to x.\n\nfind the minimal dt_delay in various delay channel.\n\nExamples\n\njulia> A =  [[0.09,0.09,0.1],[0.3,0.09,0.1],[0.09]]\n3-element Vector{Vector{Float64}}:\n [0.09, 0.09, 0.1]\n [0.3, 0.09, 0.1]\n [0.09]\n\n julia> x=0.09\n 0.09\n\njulia> find_next_delay_vec(A, x)\n([1, 2, 3], [2, 1, 1])\n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.find_num_in_vec-Union{Tuple{T}, Tuple{Array{Vector{T}, 1}, Vector{Int64}, T}} where T","page":"API","title":"DelaySSAToolkit.find_num_in_vec","text":"function find_num_in_vec(A::Vector{Vector{T}}, position_index::Vector{Int64}, x::T)\n\nFind the number of values which in each vector elements equal to x according to the corresponding index position specified by the element in the position_index vector in the given vetcer A.\n\nExamples\n\njulia> A =  [[0.09,0.09,0.1],[0.3,0.09,0.1],[0.09]]\n3-element Vector{Vector{Float64}}:\n [0.09, 0.09, 0.1]\n [0.3, 0.09, 0.1]\n [0.09]\n\njulia> position_index =  [1,2,3]\n3-element Vector{Int64}:\n 1\n 2\n 3\n\njulia> find_num_in_vec(A::Vector, position_index::Vector{Int64}, 0.09)\n3-element Vector{Int64}:\n2\n1\n1\n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.generate_delta!-Tuple{DelaySSAToolkit.DelayDirectJumpAggregation, Any, Any, Any}","page":"API","title":"DelaySSAToolkit.generate_delta!","text":"Create delta based on the shawdow variable u_shadow\n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.update_delay_channel!-Tuple{Vector{T} where T}","page":"API","title":"DelaySSAToolkit.update_delay_channel!","text":"Update the delay channel \n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.update_delay_complete!-NTuple{4, Any}","page":"API","title":"DelaySSAToolkit.update_delay_complete!","text":"Update the state upon delay completion\n\n\n\n\n\n","category":"method"},{"location":"api/#DelaySSAToolkit.update_state_delay_Direct!-Tuple{DelaySSAToolkit.DelayDirectJumpAggregation, Any, Any, Any}","page":"API","title":"DelaySSAToolkit.update_state_delay_Direct!","text":"Update state according up the next_jump;\n\n\n\n\n\n","category":"method"},{"location":"theory/#Theory","page":"Theory","title":"Theory","text":"","category":"section"},{"location":"theory/#Exact-Stochastic-Simulation-Algorithm-(SSA)-Without-Delays","page":"Theory","title":"Exact Stochastic Simulation Algorithm (SSA) Without Delays","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"Consider a system consisting of N geq 1 chemical species, X_1ldots X_N, undergoing M geq 1 chemical reactions through reaction channels R_1ldotsR_M, each of which is equipped with a propensity function (or intensity function in the mathematics literature), a_k(X). The dynamic state of this chemical system can be described by the state vector X(t) =X_1(t)ldotsX_N(t)^T, where X_n(t)n = 1ldotsN is the number of X_n molecules at time t, and ^T denotes the transpose of the vector in the bracket.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Following Gillespie, the dynamics of reaction R_k defined by a state-change vector nu_k = nu_1k ldotsnu_Nk^T, where nu_nk gives the changes in the X_n molecular population produced by one R_k reaction, and a propensity function a_k(t) together with the fundamental premise of stochastic chemical kinetics:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\na_k(t)Delta t = text the probability given  X(t)=x \nquad textthat one reaction R_k text will occur in the\nquad textnext infinitesimal time interval tt+Delta t\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Defining the probability rate constant c_k as the probability that a randomly selected combination of R_k reactant molecules reacts in a unit time period, we can calculate  a_k(t) from c_k and the molecular numbers of R_k reactants at time t using the method given by Gillespie.","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"For a chemical system in a given state X(t)=x at time t,assuming that all reactions occur instantly, Gillespie’s exact SSA answers the following two questions: (i)  when will the next reaction occur?  (ii)  which reaction will occur? Specifically, Gillespie’s exact SSA simulates the following event in each step:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\ntextE   textno reaction occurs in the time interval tt+Delta\n textand a reaction R_mu  textoccurs in the infinitesimal\n texttime interval t+Deltat+Delta+Delta t\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Based upon the fundamental premise Eq. (1), Gillespie showed that that Delta and mu are two independent random variables and have the following probability density functions (PDFs), respectively:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nf_Delta(Delta)=a_0(t) exp(-a_0(t)Delta) Delta  0\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nf_mu(mu)=a_mu(t) over a_0(t) mu = 1ldotsM\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where a_0(t)=beginmatrix sum_k=1^M a_k(t) endmatrix. According to the PDF Eq.(4), a realization of mu can be generated from a standard uniform random variable u_1, by taking mu to be the integer for which sum_k=1^mu-1 a_k(t)   u_1 a_0(t) leq sum_k=1^mu a_k(t);based on the PDF Eq.(3), a realization of Delta can be generated from another standard uniform random variable u_2 as Delta=ln(u_2)a_0(t). Therefore, Gillespie’s exact SSA generates a realization of mu and Delta in each step of simulation, and then updates the time and system state as tleftarrow t+Delta and  mathbfx leftarrow mathbfx+ mathbfnu_mu, respectively.","category":"page"},{"location":"theory/#Exact-SSA-For-Coupled-Chemical-Reaction-With-Delays","page":"Theory","title":"Exact SSA For Coupled Chemical Reaction With Delays","text":"","category":"section"},{"location":"theory/#Delay-Direct-method","page":"Theory","title":"Delay Direct method","text":"","category":"section"},{"location":"theory/","page":"Theory","title":"Theory","text":"  As in the derivation of Gillespie’s exact SSA, we first need to find the probability of event Eq.(2), that is defined as P(Deltamu)dDelta, where P(Deltamu) is the joint PDF of Delta and mu. Suppose that there are d ongoing reactions at timet, which will finish at t+T_1ldotst+T_d, respectively. Without loss of generality, we assume that T_1 leq T_2 leq ldots leq T_d. Unlike in the reaction system without delays where the propensity functions remain unchanged in the time interval tt+Delta, the propensity functions here change at t+T_ii=1ldotsd, due to delayed reactions. We need to take into account such changes in propensity functions when deriving  P(Deltamu).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  As in the derivation of Gillespie’s exact SSA, P(Deltamu)dDelta can be found from the fundamental premise Eq.(1) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP(Deltamu)dDelta=P_0(Delta) a_mu(Deltamu)dDelta\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where P_0(Delta) is the probability that no reaction will occur in the time interval tt+Delta, while a_mu(t+Delta)dDelta is the probability that a reaction R_mu occurs in t+Deltat+Delta+dDelta. Defining T_0=0 and T_d+1=infty, we can find P_0(Delta) for Delta that lies in different time intervals T_iT_i+1)i=0ldotsd. If Delta in T_iT_i+1), we define the event E_k as the event that no reaction occurs in the time interval t+T_kt+T_k+1)k=0ldotsk=i1, respectively,and the event  E_i  as the event that no reaction occurs in the time interval t+T_it+Delta). Then, we can express P_0(Delta) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nP_0(Delta)=P(E_0ldotsE_i)=P(E_0) prod_k=1^i P(E_k丨E_0ldotsE_k-1)\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"From the derivation of Gillespie’s exact SSA,we know that  ","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"P(E_0) = exp (a_0(t)T_1)\nP_0(E_k丨E_0ldotsE_k-1) = exp(-a_0(t+T_k)T_1)  (T_k+1T_k)k=0ldotsi1\nP(E_i丨E_0ldotsE_i-1) = exp(-a_0(t+T_i)(Delta-T_i))","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Notice that propensity functions change at t+T_k after a delayed reaction finishes, and we use a_0(t+T_k) to represent the new a_0. The probability P_0(Delta) is then given by","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\n P_0(Delta) = exp bigg (-sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k)-a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"where we assume that the first term of the exponent is equal to zero when i = 0. Since P_0(Delta) does not depend on individual propensity functions, as shown in Eq.(7), it is seen from Eq.(5) that Delta and mu are independent random variables. Combining Eq.(5) and Eq.(7) and noticing that a_mu(t+Delta)=a_mu(t+T_i) for Delta in T_iT_i+1), we obtain the PDF of Delta and mu as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginequation\nbeginaligned\n f_Delta(Delta) = a_0(t+T_i) exp bigg (-beginmatrix sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k) endmatrix - a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned\nendequation","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"and","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"f_mu(mu)= a_mu(t+T_i) over a_0(t+T_i)  mu = 1ldotsMDelta in T_iT_i+1)","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"It is not difficult to verify that int_0^infty f_Delta(Delta) dDelta = 1. In simulation, mu can be generated, from a standard uniform random variable u_1, by taking mu to be the integer for which beginmatrix sum_k=1^mu-1 a_k(t+T_i) endmatrix  u_1 a_0(t+T_i)  beginmatrix sum_k=1^mu a_k(t+T_i) endmatrix, after Delta is generated to be in the time interval T_iT_i+1).We next derive the method of generating  Delta according to its PDF in Eq.(8).","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  The cumulative distribution function of Deltacan be found from Eq.(8) as","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n F_Delta(Delta)=1 - exp  bigg (-beginmatrix sum_k=0^i-1 a_0 endmatrix(t+T_k)(T_k+1-T_k)-a_0(t+T_i)(Delta-T_i) bigg ) \n Delta in T_iT_i+1) i = 0ldotsd\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"Then, we can generate Delta from a standard uniform random variable u_2, by taking Delta=F_Delta^1(u_2), where F_Delta^1(cdot) represents the inverse of F_Delta(Delta). More specifically, we can obtain Delta as follows:","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Find T_i such that  F_Delta(T_i)  u_2  F_Delta(T_i+1), then calculate  Delta from","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"beginaligned\n Delta = T_i + -ln (1-u_2)-beginmatrix sum_k=0^i-1 a_0(t+T_k)(T_k+1-T_k) endmatrix  over a_0(t+T_i) \n Delta in T_iT_i+1)\nendaligned","category":"page"},{"location":"theory/","page":"Theory","title":"Theory","text":"  Since we need T_1ldotsT_d to generate Delta and mu, we define an array of data structures, named Tstruct, whose ith (i=1ldotsd) cell stores T_i and the index, mu_i, of the reaction that T_i is associated with. The reaction index mu_i is needed during the generation of Delta, when we update the propensity functions affected by the reaction that is delayed but finishes at t+T_i. During simulation, we need to generate Delta and mu, maintain Tstruct, and then update the state vector X(t).","category":"page"},{"location":"tutorials/delay_multidegradation/#A-multi-next-delay-example","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/#Model-definition","page":"A multi-next-delay example","title":"Model definition","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"The model is defined as follows: 1. Cemptyset rightarrow X_A; 2. gamma  X_A rightarrow emptyset   3 beta  X_A rightarrow  X_I1+X_I2, which triggers X_I1X_I2Rightarrow emptyset after tau time; 4. gamma  X_I1 rightarrow emptyset; 5. gamma  X_I2 rightarrow emptyset. The 4th and 5th reactions will cause the delay channel to change its state during a schduled delay reaction. Note this example is to test multiple delay reactions. The exact solution can be found in this example.","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"We first define the parameters and the mass-action jump (see Defining a Mass Action Jump for details).","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"C, γ, β, τ = [2., 0.1, 0.5, 15.]\nrate1 = [C,γ,β,γ,γ]\nreactant_stoch = [[],[1=>1],[1=>1],[2=>1],[3=>1]]\nnet_stoch = [[1=>1],[1=>-1],[1=>-1,2=>1,3=>1],[2=>-1],[3=>-1]]\nmass_jump = MassActionJump(rate1, reactant_stoch, net_stoch; scale_rates =false)\njumpsets = JumpSet((),(),nothing,[mass_jump])","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"We can see the definition of the parameters in this example.","category":"page"},{"location":"tutorials/delay_multidegradation/#Defining-a-DelayJumpSet","page":"A multi-next-delay example","title":"Defining a DelayJumpSet","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Then we turn to the definition of delay reactions","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"delay_trigger_affect! = function (de_chan, rng)\n   append!(de_chan[1], τ)\n   append!(de_chan[2], τ)\nend\ndelay_trigger = Dict(3=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>-1],2=>[3=>-1]) \n\ndelay_affect1! = function (de_chan, rng)\n    i = rand(rng, 1:length(de_chan[1]))\n    deleteat!(de_chan[1],i)\nend\ndelay_affect2! = function (de_chan, rng)\n    i = rand(rng, 1:length(de_chan[2]))\n    deleteat!(de_chan[2],i)\nend\ndelay_interrupt = Dict(4=>delay_affect1!,5=>delay_affect2!) \ndelaysets = DelayJumpSet(delay_trigger,delay_complete,delay_interrupt)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"delay_trigger  \nKeys: Indices of reactions defined in jumpset that can trigger the delay reaction. Here we have the 3rd reaction beta  X_A rightarrow  X_I1+X_I2 that will trigger the X_I1 and X_I2 to degrade after time tau.\nValues: A update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the delay channel 1 (which is the channel for X_I1) and the delay channel 2 (which is the channel for X_I2 ) will be added a delay time tau.\t\t\t\t\t\ndelay_interrupt\nKeys: Indices of reactions defined in jumpset that can cause the change in delay channel. In this example, the 4th reaction gamma  X_I1 rightarrow emptyset and the 5th reaction gamma  X_I2 rightarrow emptyset will change the schduled delay reaction to change its state immediately.\nValues: A update function that determines how to update the delay channel. In this example, once a delay-interrupt reaction happens, any of the reactants X_I1 and X_I2 that are supposed to leave the system after time tau can be degraded immediately.\ndelay_complete: \nKeys: Indices of delay channel. Here the 1st delay channel corresponds to X_I1 and the 2 nd delay channel corresponds to X_I2 .\nValues: A vector of Pairs, mapping species id to net change of stoichiometric coefficient.","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Now we can initialise the problem by setting","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"u0 = [0,0,0]\ntf = 30.\nsaveat = .1\nde_chan0 = [[],[]]\np = 0.\ntspan = (0.,tf)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"where de_chan0 is the initial condition for the delay channel, which is a vector of arrays whose kth entry stores the schduled delay time for kth delay channel. Here we assume X_I1(0)X_I2(0)=0, thus only two empty arrays. Next, we choose a delay SSA algorithm DelayDirect() and define the problem","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"aggregatoralgo = DelayDirect()\nsave_positions = (false,false)\ndprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(dprob, aggregatoralgo, jumpsets, save_positions = (false,false))\ndjprob = DelayJumpProblem(jprob,delaysets,de_chan0)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"where DelayJumpProblem inputs JumpProblem, DelayJumpSet and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/delay_multidegradation/#Visualisation","page":"A multi-next-delay example","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Now we can solve the problem and plot a trajectory","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"sol =@time solve(djprob, SSAStepper(),seed=10, saveat =.1, save_delay_channel = false)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"(Image: multidegradation1)","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Then we simulate 10^4 trajectories and calculate the evolution of mean value for each reactant","category":"page"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"using StatsBase\nSample_size = Int(1e4)\nens_prob = EnsembleProblem(djprob)\nens =@time solve(ens_prob,SSAStepper(),EnsembleThreads(),trajectories = Sample_size, saveat = .1, save_delay_channel =false)","category":"page"},{"location":"tutorials/delay_multidegradation/#Verification-with-the-exact-solution","page":"A multi-next-delay example","title":"Verification with the exact solution","text":"","category":"section"},{"location":"tutorials/delay_multidegradation/","page":"A multi-next-delay example","title":"A multi-next-delay example","text":"Lastly, we can compare with the mean values of the exact solutions X_IX_A (Image: multidegradation2) (Image: multidegradation3)","category":"page"},{"location":"tutorials/delay_degradation/#A-birth-death-example-with-delay-degradation","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"","category":"section"},{"location":"tutorials/delay_degradation/#Model-definition","page":"A birth-death example with delay degradation","title":"Model definition","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"The model is defined as follows: 1. Cemptyset rightarrow X_A; 2. gamma  X_A rightarrow emptyset; 3. beta  X_A rightarrow  X_I, which triggers X_IRightarrow emptyset after tau time; 4. gamma X_I rightarrow emptyset, which causes the delay channel to change its state during a schduled delay reaction.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"This example is studied by Lafuerza and Toral in [1], where one can solve the solution analytically. If we denote langle X_Arangle(t) to be the mean value of X_A at time t, and langle X_Irangle(t) the mean value of X_I at time t, then","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"langle X_Arangle(t)= fracCa( 1-e^-at )quad langle X_Irangle(t) = begincases\nfracCbetaa-γbigfrac1-e^-γtγ-frac1-e^-atabig t in 0tau\nfracCbetaaBigfrac1-e^-γτγ+frac(1-e^tau(a-γ))a-γe^-atBig  t in (tauinfty)\nendcases","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"where a = β + γ.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"We first define the parameters and the mass-action jump (see Defining a Mass Action Jump for details)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"C, γ, β, τ = [2., 0.1, 0.5, 15.]\nrate1 = [C,γ,β,γ]\nreactant_stoich = [[],[1=>1],[1=>1],[2=>1]]\nnet_stoich = [[1=>1],[1=>-1],[1=>-1,2=>1],[2=>-1]]\nmass_jump = MassActionJump(rate1, reactant_stoich, net_stoich; scale_rates =false)\njumpset = JumpSet((),(),nothing,[mass_jump])","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"rates  A vector of rates of reactions.\nreactant_stoch is a vector whose kth entry is the reactant stoichiometry of the kth reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of Pairs, mapping species id to stoichiometric coefficient.\nnet_stoch  is assumed to have the same type as reactant_stoich; a vector whose kth entry is the net stoichiometry of the kth reaction. The net stoichiometry for an individual reaction is again represented as a vector of Pairs, mapping species id to the net change in the species when the reaction occurs.\nscale_rates is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. The default, scale_rates=true, corresponds to rescaling the passed in rate constants. When using MassActionJump the default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)). This means that for a reaction such as 2A oversetkrightarrow B, the jump rate function constructed by MassActionJump would be k*A*(A-1)/2!. For a trimolecular reaction like 3A oversetkrightarrow B the rate function would be k*A*(A-1)*(A-2)/3!. To avoid having the reaction rates rescaled (by 1/2 and 1/6 for these two examples), one can pass the MassActionJump constructor the optional named parameter scale_rates=false\nmass_jump  Define mass-action jumps\njumpsets  Wrap up the reactions into one jumpset.","category":"page"},{"location":"tutorials/delay_degradation/#Defining-a-DelayJumpSet","page":"A birth-death example with delay degradation","title":"Defining a DelayJumpSet","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Then we turn to the definition of delay reactions","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"delay_trigger_affect! = function (de_chan, rng)\n   append!(de_chan[1], τ)\nend\ndelay_trigger = Dict(3=>delay_trigger_affect!)\ndelay_complete = Dict(1=>[2=>-1]) \n\ndelay_affect! = function (de_chan, rng)\n    i = rand(rng, 1:length(de_chan[1]))\n    deleteat!(de_chan[1],i)\nend\ndelay_interrupt = Dict(4=>delay_affect!) \ndelaysets = DelayJumpSet(delay_trigger,delay_complete,delay_interrupt)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"delay_trigger  \nKeys: Indices of reactions defined in jumpset that can trigger the delay reaction. Here we have the 3rd reaction beta X_A rightarrow X_I that will trigger the X_I to degrade after time tau.\nValues: A update function that determines how to update the delay channel. In this example, once the delay reaction is trigged, the delay channel 1 (which is the channel for X_I) will be added a delay time tau.\t\t\t\ndelay_interrupt\nKeys: Indices of reactions defined in jumpset that can cause the change in delay channel. In this example, the 4th reaction gamma  X_I rightarrow emptyset will change the schduled delay reaction to change its state immediately.\nValues: A update function that determines how to update the delay channel. In this example, once a delay-interrupt reaction happens, any of the reactants X_I that is supposed to leave the system after time tau can be degraded immediately.  \ndelay_complete \nKeys: Indices of delay channel. Here the 1st delay channel corresponds to X_I.\nValues: A vector of Pairs, mapping species id to net change of stoichiometric coefficient.","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Now we can initialise the problem by setting ","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"u0 = [0, 0]\ntf = 30.\nsaveat = .1\nde_chan0 = [[]]\np = 0.\ntspan = (0.,tf)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"where de_chan0 is the initial condition for the delay channel, which is a vector of arrays whose kth entry stores the schduled delay time for kth delay channel. Here we assume X_I(0) = 0, thus only an empty array. Next, we choose a delay SSA algorithm DelayDirect() and define the problem","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"aggregatoralgo = DelayDirect()\nsave_positions = (false,false)\ndprob = DiscreteProblem(u0, tspan, p)\njprob = JumpProblem(dprob, aggregatoralgo, jumpset, save_positions = (false,false))\ndjprob = DelayJumpProblem(jprob,delaysets,de_chan0)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"where DelayJumpProblem inputs JumpProblem, DelayJumpSet and the initial condition of the delay channel de_chan0.","category":"page"},{"location":"tutorials/delay_degradation/#Visualisation","page":"A birth-death example with delay degradation","title":"Visualisation","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Now we can solve the problem and plot a trajectory","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"sol = solve(djprob, SSAStepper(), seed=2, saveat =.1, save_delay_channel = false)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Then we simulate 10^4 trajectories and calculate the evolution of mean value for each reactant","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"using DiffEqBase\nSample_size = Int(1e4)\nens_prob = EnsembleProblem(djprob)\nens =@time solve(ens_prob,SSAStepper(),EnsembleThreads(),trajectories = Sample_size, saveat = .1, save_delay_channel =false)","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"(Image: degradation1)","category":"page"},{"location":"tutorials/delay_degradation/#Verification-with-the-exact-solution","page":"A birth-death example with delay degradation","title":"Verification with the exact solution","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"Lastkt, we can compare with the mean values of the exact solutions X_I X_A","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"timestamps = 0:0.1:tf\na = β + γ \nmean_x_A(t) = C/a*(1-exp(-a*t))\nmean_x_I(t)= 0<=t<=τ ? C*β/(a-γ)*((1-exp(-γ*t))/γ - (1-exp(-a*t))/a) : C*β/a*((1-exp(-γ*τ))/γ + exp(-a*t)*(1-exp((a-γ)τ))/(a-γ))","category":"page"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"(Image: degradation2) (Image: degradation3)","category":"page"},{"location":"tutorials/delay_degradation/#Reference","page":"A birth-death example with delay degradation","title":"Reference","text":"","category":"section"},{"location":"tutorials/delay_degradation/","page":"A birth-death example with delay degradation","title":"A birth-death example with delay degradation","text":"[1] Lafuerza, L. F., & Toral, R. (2011). Exact solution of a stochastic protein dynamics model with delayed degradation. Physical Review E, 84(5), 051121.","category":"page"},{"location":"algorithms/delaymnrm/#Delay-Modified-Next-Reaction-Method-Algorithm","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"","category":"section"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Because the initiations are still given by the firing times of independent Poisson processes. Therefore, if T_k is the current internal time of Y_k, P_k the first internal time after T_k at which Y_k fires, and the propensity function for the kth reaction channel is given by a_k, then the time until the next initiation of reaction k(assuming no other reactions initiate or complete) is still given by Delta t_k= (P_kT_k)a_k. The only change to the algorithm will be in keeping track and storing the delayed completions. To each delayed reaction channel we therefore assign a vector, s_k, that stores the completion times of that reaction in ascending order. Thus, the time until there is a change in the state of the system, be it an initiation or a completion, will be given by:","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Delta = minDelta t_k s_k(1)  t","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"where t is the current time of the system. These ideas form the heart of our Next Reaction Method [4] for systems with delays.","category":"page"},{"location":"algorithms/delaymnrm/#Pseudo-code","page":"Delay Modified Next Reaction Method Algorithm","title":"Pseudo code","text":"","category":"section"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set t = 0. For each k leq M, set P_k = 0 and T_k = 0, and for each delayed reaction channel set s_k = infty.\nCalculate the propensity function, a_k, for each reaction.\nGenerate M independent, uniform(01) random numbers, r_k, and set P_k = ln(1r_k).\nSet Delta t_k = (P_k  T_k)a_k.\nSet Delta = min_kDelta t_k s_k(1)  t.\nSet t = t + Delta.\nIf we chose the completion of the delayed reaction mu:\nUpdate the system based upon the completion of the reaction mu.\nDelete the first row of S_mu.\nElseif reaction mu initiated and muin textND\nUpdate the system according to reaction mu.\nElseif reaction mu initiated and muin textCD\nUpdate s_mu by inserting t + tau_mu into s_mu in the second to last position.\nElseif reaction mu initiated and muin textICD\nUpdate the system based upon the initiation of reaction mu.\nUpdate s_mu by inserting t + tau_mu into s_mu in the second to last position.\nFor each k, set T_k = T_k + a_k Delta.\nIf reaction mu initiated, let r be uniform(01) and set P_mu = P_mu + ln(1r).\nRecalculate the propensity functions, a_k.\nReturn to step 4 or quit.","category":"page"},{"location":"algorithms/delaymnrm/","page":"Delay Modified Next Reaction Method Algorithm","title":"Delay Modified Next Reaction Method Algorithm","text":"[1] David F. Anderson, \"A modified Next Reaction Method for simulating chemical systems with time dependent propensities and delays\", The Journal of Chemical Physics 128, 109903(2008). https://doi/10.1063/1.2799998.","category":"page"},{"location":"algorithms/delaydirect/#Delay-Direct-Method-Algorithm","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"The number of discarded Delta will be approximately equal to the number of delayed reactions that initiate. This follows because, other than the stored completions at the time the code terminates, every delayed completion will cause one computed Delta to be discarded. Thus, Cai [1] developped an algorithm, called the Direct Method for systems with delays, in which no random variables are discarded.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"The principle of Direct Method is the same as that of the original Gillespie Algorithm and the Rejection Method above: use one random variable to calculate when the next reaction initiates and use another random variable to calculate which reaction occurs at that future time. However, Direct Method updates the state of the system and propensity functions due to stored delayed reactions during the search for the next initiation time. In this way he ensures that no random variables are discarded as in the Rejection Method. ","category":"page"},{"location":"algorithms/delaydirect/#Algorithm","page":"Delay Direct Method Algorithm","title":"Algorithm","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Suppose that at time t there are ongoing delayed reactions set to complete at times t+T_1 t+T_2 ldots t+T_d. Define T_0=0 and T_d+1=infty.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Define Tstruct, whose i-th (i=1dotsd) row stores T_i and the index, mu_i, of the reaction that T_i is associated with.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Initialize. Set the initial number of molecules of each species and set  t=0. Clear Tstruct.\nCalculate the propensity of function a_k, for each reaction k in 1ldots M.\nSet a_0=sum_k=1^Ma_k.\nGenerate  Delta.\nInput the time t and a_0=sum_k=1^Ma_k.\nGenerate an independent uniform (01) random number r_1.\nIf Tstruct is empty \nThis means there is no ongoing delay reactions, set Delta = 1a_0ln(1r_1).\nElse\nSet i=1, a_t = a_0T_1 and  F=1-e^-a_t.\nWhile F  r_1\nUpdate the state vector x_1 due to the finish of the delayed reaction t+T_i.\nIf id\nCalculate propensity a_k(t+T_i+1) due to the finish of the delayed reaction at t+T_i+1 and calculate a_0(t+T_i+1).\nUpdate a_t=a_t+a_0(t+T_i+1)(T_i+1-T_i).\nUpdate F=1-e^-a_t  i=i+1.\nElse\nSet F=1\nEndIf\nEndWhile\nCalculate Calculate propensity a_k(t+T_i) due to the finish of the delayed reaction at t+T_i and calculate a_0(t+T_i).\nSet Delta=T_i-(ln(1-r_1)+a_t-a_0(t+T_i)(T_i+1-T_i))a_0(t+T_i).\nEndIf\nIf DeltainT_iT_i+1), delete the columns 1ldotsi of T_i and set T_j=T_j-Delta.\nGenerate an independent uniform (01) random number r_2.\nFind muin1dotsm such that\nsum_k=1^mu-1 a_k  r_2 leq sum_k=1^mua_k\nwhere the a_k and a_0 are generated in step 4.\nIf muin textND , update the number of each molecular species according to the reaction mu\nIf muin textCD, update Tstruct by adding the row tau_mumu so that Tstruct(i1)Tstruct(i+11) still holds for all i.\nIf muin textICD, update the system according to the initiation of mu and update Tstruct by adding the row tau_mumu so that Tstruct(i1)Tstruct(i+11) still holds for all i.\nSet t=t+Delta.\nReturn to Step 2 or quit.","category":"page"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"Remark. Notice that in the above pseudo-code, we modified the Step 4. in the orignal algorithm but both are equivalent.","category":"page"},{"location":"algorithms/delaydirect/#Reference","page":"Delay Direct Method Algorithm","title":"Reference","text":"","category":"section"},{"location":"algorithms/delaydirect/","page":"Delay Direct Method Algorithm","title":"Delay Direct Method Algorithm","text":"[1] Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DelaySSAToolkit","category":"page"},{"location":"#DelaySSAToolkit","page":"Home","title":"DelaySSAToolkit","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Gillespie developed a stochastic simulation algorithm (SSA) to simulate stochastic dynamics of chemically reacting systems [1]. In SSA algorithm, it is assumed that all reactions occur instantaneously. While in many biochemical reactions, such as gene transcription and translation, it can take certain time to finish after the reactions are initiated [??]. Neglecting delays in certain cases may still produce acceptable results, but in some delay-sensitive cases, such as delay-induced oscillators, neglecting delays in simulation will lead to erroneous conclusions. To solve this problem, an exact SSA for chemical reaction systems with delays，Delay SSA [2, 3] was proposed, based upon the same fundamental premise of stochastic kinetics used by Gillespie in the development of his SSA.","category":"page"},{"location":"","page":"Home","title":"Home","text":"DelaySSAToolkit.jl is a tool developed on top of DiffEqJump.jl which solves the stochastic simulation with delay and contains the following features:","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Various delay stochastic simulation algorithms are provided;\nStochastic delay type is supported;\nMultiple delay channels and simultaneous delay reactions are supported;\nPriority queue and dependency graph are integrated for high computational performance;\nEcosystem with Catalyst, DiffEqJump, DifferentialEquations and more...","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DelaySSAToolkit can be installed through the Julia package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/palmtree2013/DelaySSAToolkit.jl\nusing DelaySSAToolkit","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Daniel T. Gillespie \"Exact stochastic simulation of coupled chemical reactions\", J. Phys. Chem. 1977, 81, 25, 2340–2361. https://doi.org/10.1021/j100540a008","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Xiaodong Cai, \"Exact stochastic simulation of coupled chemical reactions with delays\", The Journal of Chemical Physics 126, 124108(2007). https://doi/10.1063/1.2710253.","category":"page"}]
}
